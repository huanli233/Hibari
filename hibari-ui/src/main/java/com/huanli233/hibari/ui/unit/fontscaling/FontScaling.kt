package com.huanli233.hibari.ui.unit.fontscaling

import com.huanli233.hibari.ui.unit.fontscaling.FontScaleConverter
import androidx.annotation.AnyThread
import androidx.annotation.RestrictTo
import androidx.annotation.VisibleForTesting
import androidx.collection.SparseArrayCompat
import com.huanli233.hibari.ui.unit.Dp
import com.huanli233.hibari.ui.unit.TextUnit
import com.huanli233.hibari.ui.unit.TextUnitType
import com.huanli233.hibari.ui.unit.sp
import com.huanli233.hibari.ui.util.checkPrecondition
import kotlin.collections.get

/**
 * Converts [com.huanli233.hibari.ui.unit.TextUnit] to [com.huanli233.hibari.ui.unit.Dp] and vice-versa.
 *
 * If you are implementing this interface yourself on Android, please check the docs for important
 * optimization tips about caching.
 */
interface FontScaling {
    /**
     * Current user preference for the scaling factor for fonts.
     */
    val fontScale: Float

    /**
     * Convert [com.huanli233.hibari.ui.unit.Dp] to Sp. Sp is used for font size, etc.
     */
    fun Dp.toSp(): TextUnit {
        if (!FontScaleConverterFactory.isNonLinearFontScalingActive(fontScale)) {
            return (value / fontScale).sp
        }

        val converter = FontScaleConverterFactory.forScale(fontScale)
        return (converter?.convertDpToSp(value) ?: (value / fontScale)).sp
    }

    /**
     * Convert Sp to [Dp].
     * @throws IllegalStateException if TextUnit other than SP unit is specified.
     */
    fun TextUnit.toDp(): Dp {
        checkPrecondition(type == TextUnitType.Companion.Sp) { "Only Sp can convert to Px" }
        if (!FontScaleConverterFactory.isNonLinearFontScalingActive(fontScale)) {
            return Dp(value * fontScale)
        }

        val converter = FontScaleConverterFactory.forScale(fontScale)
        return if (converter == null) Dp(value * fontScale) else Dp(converter.convertSpToDp(value))
    }
}

/**
 * Converts [TextUnit] to [Dp] and vice-versa, using a linear conversion.
 *
 * This will be the default for most platforms except Android.
 */
interface FontScalingLinear {
    /**
     * Current user preference for the scaling factor for fonts.
     */
    val fontScale: Float

    /**
     * Convert [Dp] to Sp. Sp is used for font size, etc.
     */
    fun Dp.toSp(): TextUnit = (value / fontScale).sp

    /**
     * Convert Sp to [Dp].
     * @throws IllegalStateException if TextUnit other than SP unit is specified.
     */
    fun TextUnit.toDp(): Dp {
        check(type == TextUnitType.Companion.Sp) { "Only Sp can convert to Px" }
        return Dp(value * fontScale)
    }
}

object FontScaleConverterFactory {
    private const val ScaleKeyMultiplier = 100f

    private val CommonFontSizes = floatArrayOf(8f, 10f, 12f, 14f, 18f, 20f, 24f, 30f, 100f)

    @VisibleForTesting
    @Volatile
    var sLookupTables = SparseArrayCompat<FontScaleConverter>()

    /**
     * This is a write lock only! We don't care about synchronization on reads; they can be a bit
     * out of date. But all writes have to be atomic, so we use this similar to a
     * CopyOnWriteArrayList.
     */
    private val LookupTablesWriteLock = arrayOfNulls<Any>(0)
    private const val MinScaleForNonLinear = 1.03f

    init {
        // These were generated by frameworks/base/tools/fonts/font-scaling-array-generator.js and
        // manually tweaked for optimum readability.
        synchronized(LookupTablesWriteLock) {
            putInto(
                sLookupTables,
                /* scaleKey= */ 1.15f,
                FontScaleConverterTable(
                    floatArrayOf(8f, 10f, 12f, 14f, 18f, 20f, 24f, 30f, 100f),
                    floatArrayOf(9.2f, 11.5f, 13.8f, 16.4f, 19.8f, 21.8f, 25.2f, 30f, 100f)
                )
            )
            putInto(
                sLookupTables,
                /* scaleKey= */ 1.3f,
                FontScaleConverterTable(
                    floatArrayOf(8f, 10f, 12f, 14f, 18f, 20f, 24f, 30f, 100f),
                    floatArrayOf(10.4f, 13f, 15.6f, 18.8f, 21.6f, 23.6f, 26.4f, 30f, 100f)
                )
            )
            putInto(
                sLookupTables,
                /* scaleKey= */ 1.5f,
                FontScaleConverterTable(
                    floatArrayOf(8f, 10f, 12f, 14f, 18f, 20f, 24f, 30f, 100f),
                    floatArrayOf(12f, 15f, 18f, 22f, 24f, 26f, 28f, 30f, 100f)
                )
            )
            putInto(
                sLookupTables,
                /* scaleKey= */ 1.8f,
                FontScaleConverterTable(
                    floatArrayOf(8f, 10f, 12f, 14f, 18f, 20f, 24f, 30f, 100f),
                    floatArrayOf(14.4f, 18f, 21.6f, 24.4f, 27.6f, 30.8f, 32.8f, 34.8f, 100f)
                )
            )
            putInto(
                sLookupTables,
                /* scaleKey= */ 2f,
                FontScaleConverterTable(
                    floatArrayOf(8f, 10f, 12f, 14f, 18f, 20f, 24f, 30f, 100f),
                    floatArrayOf(16f, 20f, 24f, 26f, 30f, 34f, 36f, 38f, 100f)
                )
            )
        }
        val minScaleBeforeCurvesApplied = getScaleFromKey(sLookupTables.keyAt(0)) - 0.01f
        checkPrecondition(minScaleBeforeCurvesApplied > MinScaleForNonLinear) {
            "You should only apply non-linear scaling to font scales > 1"
        }
    }

    /**
     * Returns true if non-linear font scaling curves would be in effect for the given scale, false
     * if the scaling would follow a linear curve or for no scaling.
     *
     *
     * Example usage:
     * `isNonLinearFontScalingActive(getResources().getConfiguration().fontScale)`
     */
    @AnyThread
    fun isNonLinearFontScalingActive(fontScale: Float): Boolean {
        return fontScale >= MinScaleForNonLinear
    }

    /**
     * Finds a matching FontScaleConverter for the given fontScale factor.
     *
     * @param fontScale the scale factor, usually from [Configuration.fontScale].
     *
     * @return a converter for the given scale, or null if non-linear scaling should not be used.
     */
    @AnyThread
    fun forScale(fontScale: Float): FontScaleConverter? {
        if (!isNonLinearFontScalingActive(fontScale)) {
            return null
        }
        val lookupTable = FontScaleConverterFactory[fontScale]
        if (lookupTable != null) {
            return lookupTable
        }

        // Didn't find an exact match: interpolate between two existing tables
        val index = sLookupTables.indexOfKey(getKey(fontScale))
        if (index >= 0) {
            // This should never happen, should have been covered by get() above.
            return sLookupTables.valueAt(index)
        }
        // Didn't find an exact match: interpolate between two existing tables
        val lowerIndex = -(index + 1) - 1
        val higherIndex = lowerIndex + 1
        return if (higherIndex >= sLookupTables.size()) {
            // We have gone beyond our bounds and have nothing to interpolate between. Just give
            // them a straight linear table instead.
            // This works because when FontScaleConverter encounters a size beyond its bounds, it
            // calculates a linear fontScale factor using the ratio of the last element pair.
            val converter =
                FontScaleConverterTable(floatArrayOf(1f), floatArrayOf(fontScale))

            // Cache for next time.
            put(fontScale, converter)
            converter
        } else {
            val startTable: FontScaleConverter
            val startScale: Float
            if (lowerIndex < 0) {
                // if we're in between 1x and the first table, interpolate between them.
                // (See b/336720383)
                startScale = 1f
                startTable = FontScaleConverterTable(CommonFontSizes, CommonFontSizes)
            } else {
                startScale = getScaleFromKey(
                    sLookupTables.keyAt(lowerIndex)
                )
                startTable = sLookupTables.valueAt(lowerIndex)
            }
            val endScale = getScaleFromKey(
                sLookupTables.keyAt(higherIndex)
            )
            val interpolationPoint =
                MathUtils.constrainedMap(
                    rangeMin = 0f,
                    rangeMax = 1f,
                    startScale,
                    endScale,
                    fontScale
                )
            val converter = createInterpolatedTableBetween(
                startTable,
                sLookupTables.valueAt(higherIndex),
                interpolationPoint
            )

            // Cache for next time.
            put(fontScale, converter)
            converter
        }
    }

    private fun createInterpolatedTableBetween(
        start: FontScaleConverter,
        end: FontScaleConverter,
        interpolationPoint: Float
    ): FontScaleConverter {
        val dpInterpolated = FloatArray(CommonFontSizes.size)
        for (i in CommonFontSizes.indices) {
            val sp = CommonFontSizes[i]
            val startDp = start.convertSpToDp(sp)
            val endDp = end.convertSpToDp(sp)
            dpInterpolated[i] = MathUtils.lerp(startDp, endDp, interpolationPoint)
        }
        return FontScaleConverterTable(CommonFontSizes, dpInterpolated)
    }

    private fun getKey(fontScale: Float): Int {
        return (fontScale * ScaleKeyMultiplier).toInt()
    }

    private fun getScaleFromKey(key: Int): Float {
        return key.toFloat() / ScaleKeyMultiplier
    }

    private fun put(scaleKey: Float, fontScaleConverter: FontScaleConverter) {
        // Dollar-store CopyOnWriteSparseArray, since this is the only write op we need.
        synchronized(LookupTablesWriteLock) {
            val newTable = sLookupTables.clone()
            putInto(newTable, scaleKey, fontScaleConverter)
            sLookupTables = newTable
        }
    }

    private fun putInto(
        table: SparseArrayCompat<FontScaleConverter>,
        scaleKey: Float,
        fontScaleConverter: FontScaleConverter
    ) {
        table.put(getKey(scaleKey), fontScaleConverter)
    }

    private operator fun get(scaleKey: Float): FontScaleConverter? {
        return sLookupTables[getKey(scaleKey)]
    }
}

